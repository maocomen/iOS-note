[TOC]

# 23 种设计模式

## 前言

### 简单工厂

简单工厂并不是一个标准的设计模式。

#### 定义

提供一个==创建对象实例==的功能，而无需关心其具体实现。被创建的类型可以是接口、抽象类，也可以是具体的类。（ OC 中并没有接口类这个概念，OC 中应该是实现了接口的类）

#### 认识

简单工厂的功能：创造东西。

使用简单工厂的时候，通常不需要创建简单工厂的实例，没有创建实例的必要。因此可以把简单工厂实现成一个工具类，直接食用静态方法就可以了（类方法）。所以简单工厂也被称为==静态工厂==。

一个简单工厂可以包含很多用来构造东西的方法，一个简单工厂理论上可以构造任何东西，所以又可以称为==万能工厂==。

#### 优缺点

优点：

* 帮助封装

  简单工厂虽然简单，但是非常友好地帮助我们实现了组件的封装，然后让组件外部能真正面向接口编程。

* 解耦

  实现了客户端和具体实现类的解耦。

缺点：

* 可能增加客户端的复杂度

  如果通过客户端的参数来选择具体的实现类，那么就必须让客户端理解各个参数所代表的具体功能和含义，这样会增加客户端使用的难度，也部分暴露了内部实现，这种情况可以选用可配置的方式来实现。（配置的优缺点，由谁配置）

* 不方便扩展子工厂

  私有化简单工厂的构造方法之后，也就不能通过拓展子类来改变创建接口的方法的行为了。（通常情况下也不需要为简单工厂创建子类）

#### 思考

简单工厂的本质：选择实现。

## 正文

### 外观模式 （ Facade ）

#### 定义

为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

#### 认识

外观模式的目的：为了让外部减少与子系统内多个模块的交互，松散耦合，从而让外部能够更简单地使用子系统。

外观是当作子系统对外的接口出现的，虽然也可以在这里定义一些子系统没有的功能，但是不建议这么做。外观应该是包装已有的功能，主要负责组合已有功能来实现客户需要，而不是添加新的实现。

#### 优缺点

优点：

* 松散耦合

  外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。

* 简单易用

  外观类为外部客户端使用子系统提供了一站式服务。

  外观模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟外观交互就好了。

* 更好地划分访问的层次

  有些方法是对系统内的，有些方法是对系统外的。把需要暴露给外部的功能集中到外观中，既方便客户端使用，又很好地隐藏了内部的细节。

缺点：

* 过多的或者不太合理的 Facade 容易让人迷惑。

#### 思考

外观模式的本质：封装交互，简化调用。

很好地体现了==最少知道原则==。

### 适配器模式（ Adapter ）

#### 定义

将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

#### 认识

适配器模式的主要功能：进行转换匹配，目的是复用已有的功能，而不是来实现新的接口。客户端需要的功能应该是已经实现好了的，不需要适配器模式来实现，适配器模式主要负责把不兼容的接口转换成客户端期望的样子。

适配器里面可以实现功能，这种适配器叫做智能适配器。在接口匹配和转换的过程中，也有可能需要额外实现一定的功能，才能转换过来，比如需要调整参数以进行匹配等。

适配器的实现方式其实是依靠对象组合的方式。通过给适配器对象组合被适配的对象，然后当客户端调用 [^Target] 的时候，适配器会把相应的功能委托给被适配的对象去完成。

使用适配器又一个潜在的问题，就是被适配的对象不再兼容 [^Adaptee] 的接口，因为适配器只是实现了 [^Target] 的接口。这导致并不是所有 [^Adaptee] 对象可以被使用的地方都能使用适配器。

双向适配器同时实现了 [^Target] 和 [^Adaptee] 的接口，使得双向适配器可以在 [^Target] 或 [^Adaptee] 被使用的地方使用，以提供对所有客户的透明性。尤其在两个不同的客户需要使用不同的方式查看一个同一个对象时，适合使用双向适配器。

对象适配器 类适配器（多重继承）

（ OC 中没有多重继承，但是可以实现多个协议）



#### 优缺点

优点：

* 更好的复用性

  如果功能是已经有了的，只是接口不兼容，那么通过适配器模式就可以让这些功能得到更好的复用。

* 更好的可扩展性

  在实现适配器的功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。

缺点：

* 过多地使用适配器，会让系统非常零乱，不容易整体进行把握。

  明明调用的是 A 接口，内部却被适配成了 B 接口来实现，一个系统如果太多出现这种情况，无异于一场灾难。如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 

#### 思考

适配器模式的本质：转换匹配，复用功能。

通过转换调用已有的实现，从而能把已有的实现匹配成需要的接口，使之能满足客户端的需要。

转换匹配是手段，复用已有的功能才是目的。



### 单例模式 （ Singleton ）

#### 定义

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

实现：

* 懒汉式

  装载类的时候不创建对象实例，而是等到第一次使用的时候才去创建实例。

* 饿汉式

  装载类的时候就创建对象实例。

#### 认识

单例模式的功能：用来保证这个类在运行期间只会被创建一个类实例，单例模式还提供了一个全局卫衣访问这个实例的访问点。不管采用懒汉式还是饿汉式的实现方式，这个全局访问点事一样的。

单例只关心类实例的创建问题，并不关心具体的业务功能。

懒汉式的实现方式体现了[^延迟加载]的思想。

懒汉式的实现方式还体现了[^缓存]的思想。

#### 两种实现方式的比较

* 时间空间角度

  两者相比：

  懒汉式是典型的时间换空间，每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。当然，如果一直没有人使用的话，那就不会创建实例，节约内存空间。

  饿汉式是典型的空间换时间，当类装载的时候就会创建类实例，不管后面用不用，先创建出来，然后每次调用的时候，就不需要再判断了，节省了运行时间。

* 线程安全角度

  1. 不加同步的懒汉式是线程不安全的。

     两个线程，一个线程 A ，一个线程 B ，同时调用 getInstance 方法，就可能导致并发问题。

  2. 饿汉式是线程安全的，在装载类的时候是不会发生并发的。

  3. 懒汉式加同步锁可以解决线程安全问题。

  4. 双重检查加锁机制。

#### Java 中更好的单例实现方式

使用静态嵌套类。（OC 中没有这个机制，swift 中有更加简洁方便的单例实现方式）。

枚举实现单例。

* java 中枚举是类，OC 和 Swift 中枚举不是类。

#### 思考

单例模式的本质：控制实例数目。

### 工厂方法模式 （ Factory Method ）

#### 定义

定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类的实例化延迟到其子类。

#### 认识

工厂方法模式的主要功能是让父类在不知道具体实现的情况下，完成自身的功能调用；而具体的实现延迟到子类来实现。

工厂方法的实现中，通常父类会是一个抽象类，里面包含创建所需对象的抽象方法，这些抽象方法就是工厂方法。

子类在实现这些抽象方法的时候，通常并不是由子类来实现具体的功能，而是在子类的方法里面做选择，选择具体的产品实现对象。

父类中，通常会有使用这些产品对象来实现一定功能的方法，而且这些方法所水岸的功能通常都是公用的功能，不管子类选择了何种具体的产品实现，这些方法的功能总是能正确执行。

也可以把父类实现成一个具体的类。这种情况下，通常是父类中提供获取所需对象的默认实现方法，这样即使没有具体的子类，也能够运行。

通常这种情况还是需要具体的子类来决定具体要如何创建父类所需要的对象，也把这种情况称为工厂方法为子类提供了挂钩。通过工厂方法，可以让子类对象来覆盖父类的实现，从而提供更好的灵活性。

#### 工厂方法模式与 IoC／DI

IoC — InversionofControl ，控制反转

DI — DependencyInjection，依赖注入。

**控制反转**

* 如果要在 A 中使用 C ，一般的做法是在 A 中直接创建 C 的对象，也就是说，在 A 类中主动去获取所需要的外部资源 C ，这种情况是正向的。
* 如果 A 类不再主动去获取 C ，而是被动等待，等待 IoC／DI 的容器获取一个 C 的实例，再注入到 A 类中，这种情况是反向的，就是控制反转了。

工厂方法模式和 IoC／DI 的思想是类似的，都是“主动变被动”，进行了“主从换位”，从而获得了更灵活的程序结构。

#### 优缺点

优点：

* 可以在不知具体实现的情况下编程
* 更容易扩展对象的新版本
* 连接平行的类层次

缺点：

* 具体产品对象和工厂方法的耦合性

#### 思考

工厂方法模式的本质：延迟到子类来选择实现。

从本质上来讲，工厂方法模式和简单工厂是非常类似的，在具体实现上都是“选择实现”；而工厂方法会把这个工作延迟到子类来实现，工厂类里面使用工厂方法的地方是依赖于抽象而不是具体的实现，从而使得系统更加灵活，具有更好的可维护性和可扩展性。

从某个角度来讲，可以认为简单工厂就是工厂方法模式的一种特例。

工厂方法模式很好地体现了[^依赖倒置原则]。具体来说，就是不能让高层组建依赖于低层组件，而且不管高层组件还是低层组件，都应该依赖于抽象。

### 抽象工厂模式 （ Abstract Factory ）

#### 定义

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

#### 认识

抽象工厂的功能是为一系列相关对象或相互依赖的对象创建一个接口。这个接口内的方法不是任意堆砌的，而是一系列相关或互相依赖的方法。

从某种意义上来看，抽象工厂其实是一个产品系列，或者产品簇。

抽象工厂定义的一系列对象通常是相关或者互相依赖的，这些产品对象就构成了一个产品簇，也就是抽象工厂定义了一个产品簇。

切换一个产品簇的时候，只要提供不同的抽象工厂实现就可以了，也就是说现在是以产品簇作为一个整体被切换。

#### 优缺点

优点：

* 分离接口和实现

  客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已。客户端从具体的产品实现中解耦。

* 使得切换产品簇变得容易

  客户端使用不同的工厂实现，就相当于是在切换不同的产品簇。

缺点：

* 不太容易扩展新的产品

* 容易造成类层次复杂

  如果需要选择的层次过多，那么会造成整个类层次变的复杂。

#### 思考

抽象工厂的本质：选择产品簇的实现。

工厂方法是选择单个产品的实现，虽然一个类里面可以有多个工厂方法，但是这些方法之间一般是没有联系的，即使看起来像有联系。

抽象工厂着重的就是为一个产品簇选择实现，定义在抽象工厂里面的方法通常是有联系的，它们都是产品的某一部分或者是相互依赖的。如果抽象工厂里面只定义一个方法，直接创建产品，那么就退化成为工厂方法了。

### 生成器模式 （ Builder ）

#### 定义

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

要实现同样的构建过程可以创建不同的表现，那么一个自然的思路就是先把构建过程独立出来，在生成器模式中把它称为指导者，由它来指导装配过程，但是不负责每步具体的实现。光有指导者是不够的，必须要有能具体实现每步的对象，在生成器模式中称这些实现对象为生成器。

#### 认识

生成器模式的主要功能是构建复杂的产品，而且是细化的、分步骤的构建产品，也就是生成器模式重在一步一步解决构造复杂对象的问题。

这个构建过程是统一的，固定不变的，变化的部分放到生成器部分了，只要配置不同的生成器，那么同样的构建过程，就能构建出不同的产品。

生成器模式的重心在于分离构建算法和具体的构造实现，从而使得构建算法可以重用。具体的构造实现可以很方便地扩展和切换，从而可以灵活地组合来构造出不同的产品对象。

#### 优缺点

优点：

* 松散耦合

  可以用同一个构建算法构建出表现上完全不同的产品，实现产品构建和产品表现上的分离。生成器模式正是把产品构建的过程独立出来，使它和具体产品的表现松散耦合，从而使得构建算法可以复用，而具体产品表现也可以灵活地、方便地扩展和切换。

* 可以很容易地改变产品的内部表示

  Builder 对象只是提供结构给 Director 使用，那么具体的部件创建和装配方式是被 Builder 接口隐藏了的，Director 并不知道这些具体的实现细节。这样以来，要想改变产品的内部表示，只需要切换 Builder 的具体实现即可。

* 更好的复用性

  生成器模式很好地实现了构建算法和具体产品实现的分离。使得构建产品的算法可以复用。同样的道理，具体产品的实现也可以复用，同一个产品的实现，可以配合不同的构建算法使用。

#### 思考

生成器模式的本质：分离整体构建算法和部件构造。

构建一个复杂的对象，本来就有构建的过程，以及构建过程中具体的体现。生成器模式就是用来分离这两个部分，从而使得程序结构更松散、扩展更容易、复用性更好，同时也会使得代码更清晰，意图更明确。

虽然在生成器模式的整体构建算法中，会一步一步引导 Builder 来构建对象，但这并不是说生成器主要就是用来实现分步骤构建对象的。生成器模式的重心还是在与分离整体构建算法和部件构造，而分步骤构建对象不过是整体构建算法的一个简单表现，或者说是一个附带产物。

### 原型模式 （ Prototype ）

#### 定义

用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

通过原型实例创建新的对象，就不再需要关心这个实例本身的类型，也不关心它的具体实现，只要实现了克隆自身的方法，就可以通过这个方法来获取新的对象，而无须再去通过 new 来创建。

#### 认识

原型模式的功能：

* 通过克隆来创建新的对象的实例；
* 为克隆出来的新的对象实例肤质原型实例属性的值。

原型模式要实现的主要功能就是：通过克隆创建新的对象实例。一般来讲，新创建出来的实例的数据是和原型实例一样的。但是具体如何实现克隆，需要由程序自行实现，原型模式并没有统一的要求和实现算法。

原型模式从某种意义上说，就是 new 操作，克隆方法创建实例“类似于 new ”，而不是“就是 new ”。

克隆方法和 new 操作最明显的不同就在于：new 一个对象实例，一般属性是没有值的，或者是只有默认值；如果是克隆得到的一个实例，通常属性是有值的，属性的值就是原型对象实例在克隆的时候，原型对象实例的属性的值。

原型实例和克隆出来的实例，本质上是不同的实例，克隆完成后，它们之间是没有关联的，如果克隆完成后，克隆出来的实例的属性值发生了改变，是不会影响到原型实例的。

#### 浅拷贝与深拷贝（浅度克隆与深度克隆）

* 浅度克隆

  只负责克隆按值传递的数据 （比如基本数据类型、String 类型）

* 深度克隆

  除了浅度克隆要克隆的值外，还负责克隆引用类型的数据，基本上就是被克隆实例所有的属性数据都会被克隆出来。

  如果被克隆的对象里面的数据类型是引用类型，也就是属性的类型也是对象，则需要一直递归地克隆下去。这也意味着，要想深度克隆成功，必须要争个克隆所涉及的对象都要正确实现克隆方法，如果其中有一个没有正确实现克隆，那么就会导致克隆失败。

#### 优缺点

原型模式的优点：

* 对客户端隐藏具体的实现类型

  原型模式的客户端只知道原型接口的类型，并不知道具体的实现类型，从而减少了客户端对这些具体实现类型的依赖。

* 在运行时动态改变具体的实现类型

  原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态地改变具体的实现类型，看起来接口没有任何变化，但其实运行的已经是另外一个类实例了。因为克隆一个原型就类似于实例化一个类。

缺点：

* 每个原型的子类都必须实现 clone 的操作，尤其在包含引用类型的对象时，clong 方法会比较麻烦，必须要能够递归地让所有的相关对象都要正确地实现克隆。

#### 思考

原型模式的本质：克隆生成对象。

克隆是手段，目的是生成新的对象实例。正是因为原型的目的是为了生成新的对象实例，原型模式通畅是被归类为创建行的模式。

原型模式也可以用来解决“只知接口而不知实现的问题”，使用原型模式，可以出现一种独特的“接口造接口”的景象，在面向接口编程中很有用。同样的功能也可以考虑使用工厂来实现。

原型模式的重心还是在创建新的对象实例，至于创建出来的对象，其属性的值是否一定要和原型对象属性的值完全一样，这个并没有强制规定，只不过在目前大多数实现中，克隆出来的对象和原型对象的属性值是一样的。

可以通过克隆来创建值不一样的实例，但是对象类型必须一样。可以有部分甚至是全部的属性的值不一样，可以有选择性的克隆。

### 中介者模式 （ Mediator ）

#### 定义

用一个中介对象来封装一系列的对象交互。中介者使得各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

#### 认识

中介者的功能非常简单，就是封装对象之间的交互。如果一个对象的操作会引起其他相关对象的变化，或者是某个操作需要引起其他对象的后续或连带操作，而这个对象又不希望自己来处理这些关系，那么就可以找中介者，把所有的麻烦扔给它，只在需要的时候通知中介者，其他的就让中介者去处理就可以了。其他的对象在操作的时候，可能会引起这个对象的变化，也可以这么做。

对象之间完全分离，谁都不直接跟其他对象交互，那么相互的关系全部被集中到中介者对象里，所有的对象只是跟中介对象进行通信，相互之间不再有联系。

把所有对象之间的交互都封装在中介者中，能够集中控制这些对象的交互关系，每当有变化的时候，修改起来就会很方便。

#### 优缺点

优点：

* 松散耦合

  将多个同事对象的交互封装到中介者对象中，从而使得同事对象之间松散耦合，基本上可以做到互不依赖。同事对象就可以独立地变化和复用。

* 集中控制交互

  多个同事对象的交互，被封装在中介者对象里集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那就扩展中介者对象，而各个同事类不需要做修改。

* 多对多变成一对多

缺点：

* 过度集中化。如果同事对象的交互非常多，而且比较复杂，当这些复杂性全部集中到中介者的时候，会导致中介者对象变的十分复杂，而且难于管理和维护。

#### 思考

中介者模式的本质：封装交互。

中介者模式的目的，就是用来封装多个对象的交互，这些交互的处理多在中介者对象里面实现。因此中介对象的复杂程度，就取决于它封装的交互的复杂程度。

### 代理模式（ Proxy ）

#### 定义

为其他对象提供一种代理以控制对这个对象的访问。

#### 认识

代理模式是通过创建一个代理对象，用这个代理对象去代表真实的对象，客户端得到这个代理对象后，对客户端没有什么影响，就跟得到了真实对象一样来使用。

当客户端操作代理对象的时候，实际上功能最终还是会由真实的对象来完成，只不过是通过代理操作的，也就是客户端操作代理，代理操作真正的对象。

正是因为有代理对象夹在客户端和被代理的真实对象中介，相当于一个中转，在中转的时候就可以做很多操作。

代理的种类：

* 虚代理

  根据需要来创建开销很大的对象，该对象只有在需要的时候才会被真正的创建。

* 远程代理

  用来在不同的地址空间上代表同一个对象（ Java 中的 RMI 技术）。

* copy-on-write 代理

  在客户端操作的时候，只有对象确实改变了，才会真的拷贝（或克隆）一个目标对象，算是虚代理的一个分支。

* 保护代理

  控制对原始对象的访问，如果有需要，可以给不同的用户提供不同的访问权限，以控制他们对原始对象的访问。

* Cache 代理

  为那些昂贵操作的结果提供临时饿存储空间，以便多个客户端可以共享这些结果。

* 防火墙代理

  保护对象不被恶意用户访问和操作。

* 同步代理

  使多个用户能够同时访问目标对象而没有冲突。

* 智能指引

  在访问对象时执行一些附加操作，比如，对指向实际对象的引用计数、第一次引用一个持久对象时，将它装入内存。

在这些代理类型中，最常见的是虚代理、保护代理、远程代理和智能指引这几种。

#### 特点

代理模式在客户和被客户访问的对象之间，引入了一定程度的间接性，客户是直接使用代理，让代理来与被访问的对象进行交互。不同的代理类型，这种附加的间接性有不同的用途，也就具有不同的特点。

- 远程代理：隐藏了一个对象存在于不同的地址空间的事实，也即是客户通过远程代理去访问一个对象，根本不关心这个对象在哪里，也不关心如何通过网络去访问到这个对象。从客户的角度来讲，它只是在使用代理对象而已。
- 虚代理：可以根据需要来创建“大”对象，只有到必须创建对象的时候，虚代理才会创建对象，从而大大加快程序运行速度，并节省资源。通过虚代理可以对系统进行优化。
- 保护代理：可以在访问一个对象的前后，执行很多附加的操作，除了进行权限控制之外，还可以进行很多跟业务相关的处理，而不需要修改被代理的对象。也就是说，可以通过代理来给目标对象增加新功能。
- 智能指引：和保护代理类似，也是允许在访问一个对象的前后，执行很多附加的操作，这样依赖就可以做很多额外的事情，比如，引用计数等。

#### 思考

代理模式的本质：控制对象访问。

代理模式通过代理目标对象，把代理对象插入到客户和目标之间，从而为客户和目标对象引入一定的间接性。正是这个间接性，给了代理对象很多的活动空间。代理对象可以在调用具体的目标对象前后，附加很多操作，从而实现新的功能或是拓展目标对象的功能。更狠的是，代理对象还可以不去创建和调用目标对象，也就是说，目标对象被完全代理掉了，或是被替换掉了。

从实现上看，代理模式主要是使用对象的组合和委托，尤其是在静态代理的实现里面，会看得更清楚。但是也可以采用对象继承的方式来实现代理，这种实现方式在某些情况下，比使用对象组合还要来的简单。

### 观察者模式（ Observer ）

#### 定义

定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

#### 认识

目标和观察者之间的关系

* 目标和观察者之间是典型的一对多的关系。多个观察者观察同一个目标（引申：多个观察者观察多个目标，一个观察者观察一个目标）

在观察者模式中，观察者和目标是单向依赖的，只有观察者依赖于目标，而目标是不会依赖于观察者的。

他们之间联系的主动权掌握在目标手中，只有目标知道什么时候需要通知观察者。在整个过程中，观察者始终是被动的，被动地等待目标的通知，等待目标传值给它。

对目标而言，所有的观察者都是一样的，目标会一视同仁地对待。当然也可以通过在目标中进行控制，实现有区别地对待观察者，比如某些状态变化，只需要通知部分观察者，但那是属于稍微变形的用法了，不属于标准的、原始的观察者模式了。

命名建议：

* 观察者模式又被称为——订阅模式。
* 目标接口的定义，建议在名称后面跟 Subject。
* 观察者接口的定义，建议在名称后面跟 Observer。
* 观察者接口的更新方法，建议名称为 update，当然方法的参数可以根据需要定义，参数个数不限、参数类型不限。

#### 推模型和拉模型

* 推模型

  目标对象主动向观察者推送目标的详细信息，不管观察者是否需要，推送的信息通畅是目标对象的全部或部分数据，相当于是在广播通信。

* 拉模型

  目标对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到目标对象中获取，相当于是观察者从目标对象中拉数据。一般这种模型的实现中，会把目标对象自身通过 update 方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。

推模型和拉模型的区别：

* 推模型是假定目标对象知道观察者需要的数据；而拉模型是目标对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传给观察者，让观察者自己去按需取值。
* 推模型可能会使得观察者对象难以复用，因为观察者定义的 update 方法是按需定义的，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能需要提供新的 update 方法，或者是干脆重新实现观察者。

#### 优缺点

优点：

* 观察者模式实现了观察者和目标之间的抽象耦合

  原本目标对象在状态发生改变的时候，需要直接调用所有的观察者对象，但是抽象出观察者接口以后，目标和观察者就只是在抽象层面上耦合了，也就是说目标只是知道观察者接口，并不知道具体的观察者的类，从而实现目标类和具体的观察者类直接的解耦。

* 观察者模式实现了动态联动

  所谓联动，就是做一个操作会引起其他相关的操作。由于观察者模式对观察者注册实行管理，那就可以在运行期间，通过动态地控制注册的观察者，来控制某个动作的联动范围，从而实现动态联动。

* 观察者模式支持广播通信

  由于目标发送通知给观察者是面向所有注册的观察者，所以每次目标通知的信息就要对所有注册的观察者进行广播。当然，也可以通过在目标上添加新的功能来限制广播的范围。

缺点：

* 可能会引起无谓的操作

  由于观察者模式每次都是广播通信，不管观察者需不需要，每个观察者都会被调用 update 方法，如果观察者不需要执行相应处理，那么这次操作就浪费了。有可能会引起误更新。

#### 思考

观察者模式的本质：触发联动。

当修改目标对象的状态的时候，就会出发相应的通知，然后会循环调用所有注册的观察者对象的相应方法，其实就相当于联动调用这些观察者的方法。

而且这个联动还是动态的，可以通过注册和取消注册来控制观察者，因而可以在程序运行期间，通过动态地控制观察者，来变相地实现添加和删除某些功能处理，这些功能就是观察者在 update 的时候执行的功能。

同时目标对象和观察者对象的解耦，又保证了无论观察者发生怎样的变化，目标对象总是能够正确地联动过来。

### 命令模式 （ Command ）

#### 定义

将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

#### 认识

命令模式的关键之处就是把请求封装成对象，也就是命令对象，并定义了统一的执行操作的接口，这个命令对象可以被存储、转发、记录、处理、撤销等，整个命令模式都是围绕这个对象在进行。

一个接收者对象可以处理多个命令，接收者和命令之间没有约定的对应关系。接收者提供的方法个数、名称、功能和命令中的可以不一样，只要能够通过调用接收者的方法来实现命令对应的功能就可以了。

在标准的命令模式里面，命令的实现类是没有真正实现命令要求的功能的，真正执行命令的功能的是接收者。

如果命令的实现对象比较智能，它自己就能真实地实现命令要求的功能，而不再需要调用接收者，那么这种情况就称为智能命令。

也可以有半智能的命令，命令对象知道部分实现，其他的还是需要调用接收者来完成，也就是说命令的功能由命令对象和接收者共同来完成。

#### 优缺点

优点：

* 更松散的耦合

  命令模式使得发起命令的对象——客户端，和具体实现命令的对象——接受者对象完全解耦，也就是说，发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。

* 更动态的控制

  命令模式把请求封装起来，可以动态地对它进行参数化，队列化和日志化等操作，从而使得系统更灵活。

* 很自然的复合命令

  命令模式中的命令对象能狗很容易地组合成复合命令，也就是前面讲的宏命令，从而使系统操作更简单，功能更强大。

* 更好的扩展性

  由于发起命令的对象和具体的实现完全解耦，因为扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设知道命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。

#### 思考

命令模式的本质：封装请求。

命令模式的关键就是把请求封装成为命令对象，然后就可以对这个对象进行一系列的处理了，比如参数化配置、可撤销操作、宏命令、队列请求、日志请求等功能处理。

### 迭代器模式（ Iterator ）

#### 定义

提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。

#### 认识

迭代器模式的功能主要在于提供对聚合对象的迭代访问。迭代器就围绕着这个“访问”做文章，延伸出很多的功能来。

* 以不同的方式遍历聚合对象，比如向前、向后等。
* 对同一个聚合同时进行多个遍历。
* 以不同的遍历策略来遍历聚合，比如是否需要过滤等。
* 多态迭代，含义是：为不同的聚合结构提供统一的迭代接口，也就是说通过一个迭代接口可以访问不同的聚合结构，这就叫做多态迭代。标准的迭代模式实现基本上都是支持多态迭代的。

迭代器模式的关键思想就是把对聚合对象的遍历和访问从聚合对象中分离出来，放入单独的迭代器中，这样聚合对象会变得简单一些；而且迭代器和聚合对象可以独立地变化和发展，会大大加强系统的的灵活性。

#### 内部迭代器和外部迭代器

* 内部迭代器

  由迭代器内部控制迭代下一个元素的步骤，客户端无法干预。如果想要在迭代的过程中完成工作的话，客户端就需要吧操作传递给迭代器。迭代器在迭代的时候会在每个元素上执行这个操作。

* 外部迭代器

  由客户端控制迭代下一个元素的步骤。

外部迭代器比内部迭代器要灵活。

#### 优缺点

优点：

* 更好的封装性
* 迭代器模式可以让你访问一个聚合对象的内容，而无须暴露该聚合对象的内部表示，从而提高聚合对象的封装性。
* 可以以不同的遍历方式来遍历一个聚合
* 使用迭代器模式，使得聚合对象的内容和具体的迭代算法分开。这样就可以通过使用不同的迭代器的实例、不同的遍历方式来遍历一个聚合对象了。
* 迭代器简化了聚合的接口
* 有了迭代器的接口，则聚合本身就不需要再定义这些接口了，从而简化了聚合的接口定义。
* 简化客户端调用
* 迭代器为遍历不同的聚合对象提供了一个统一的接口，使得客户端遍历聚合对象的内容变得更简单。
* 同一个聚合上可以有多个遍历
* 每个迭代器保持它自己的遍历状态，比如前面实现中的迭代索引位置，因此可以对同一个聚合对象同时进行多个遍历。

#### 思考

迭代器模式的本质：控制访问聚合对象中的元素。

### 组合模式（ Composite ）

#### 定义

将对象组合成树型结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

#### 认识

让客户端不在区分操作的是组合对象还是叶子对象，而是以一个统一的方式来操作。

组合对象会组合出树型结构来，组成这个树型结构所使用的多个组件对象，就自然地形成了对象树。

组合模式中的递归，指的是对象递归组合。是对象本身的递归，是对象的组合方式，在设计上称作递归关联，是对象关联关系的一种。

安全性和透明性

* 安全性指：从客户使用组合模式上看是否更安全。如果是安全的，那么就不会有发生误操作的可能，能访问的方法都是被支持的功能。
* 透明性指：从客户使用组合模式上，是否需要区分到底是组合对象还是叶子对象。如果是透明的，那就不用再区分，对于客户而言，都是组件对象，具体的类型对于客户而言是透明的，是客户无需关心的。

#### 优缺点

优点：

* 定义了包含基本对象和组合对象的类层次结构

  组合模式中，基本对象可以被组合成复杂的组合对象，而组合对象又可以组成更复杂的组合对象，可以不断地递归组合下去，从而构成一个统一的组合对象的类层次结构

* 统一了组合对象和叶子对象

  在组合模式中，可以把叶子对象当作特殊的组合对象来看待，为它们定义统一的父类，从而把组合对象和叶子对象的行为统一起来

* 简化了客户端

  调用组合模式通过统一组合对象和叶子对象，使得客户端在使用它们的时候，不需要再去区分它们，客户不关心使用的到底是什么类型的对象，大大简化了客户端的使用。

* 更容易拓展

  客户端是统一地面对 Component 来操作，因此，新定义的 Composite 或 Leaf 子类能够很容易地与已有的结构一起工作，而客户端不需要为增添了新的组件类而改变。

缺点：

* 很难限制组合中的组件类型

  需要检测组件类型的时候，使得我们不能依靠编译期的类型约束来完成，必须在运行期间动态检测。

#### 思考

组合模式的本质：统一叶子对象和组合对象。

组合模式通过把叶子对象当作特殊的组合对象看待，从而对叶子对象和组合对象一视同仁，全部当成了 Component 对象，有机地统一了叶子对象和组合对象。

正是因为统一了叶子对象和组合对象，在将对象构建成树型结构的时候，才不需要做区分，反正是组件对象里面包含其他的组件对象，如果递归下去；也才使得对于树型结构的操作变得简单，不管对象类型，统一操作。

### 模板方法模式 （ Template Method ）

#### 定义

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

#### 认识

模板方法的功能在于固定算法骨架，而让具体算法实现可扩展。

==面向接口编程==并不是说就不再使用抽象类了。通常在“==既要约束子类的行为，又要为子类提供公共功能==”的时候使用抽象类。

==变与不变==，把不变的部分抽象出啦，进行公共的实现，将变化的部分分离出去，用接口来封装隔离，或者用抽象类来约束子类行为。

==好莱坞法则==：不要找我们，我们会联系你。

模板的写法：

* 模板方法：定义算法骨架的方法
* 具体的操作：在模板中直接实现某些步骤的方法。通常这些步骤的实现算法是固定的，而且是不怎么变化的，因此可以将其当作公共功能实现在模板中。
* 具体的 AbstractClass 操作：在模板中实现某些公共功能，可以提供给子类使用，一般不是具体的算法步骤的实现，而是一些辅助的公共功能。
* 原语操作：就是在模板中定义的抽象操作，通常是模板方法需要调用的操作，是必须的操作，而且在父类中还没有办法确定下来如何实现，需要子类来真正实现的方法。
* 钩子操作：在模板中定义，并提供默认实现的操作。钩子操作是可以被扩展的点，但不是必须的。
* FactoryMethod：在模板方法中，如果需要得到某些对象实例的话，可以考虑通过工厂方法来获取，把具体的构建对象的实现延迟到子类中去。

#### 优缺点

优点：

* 实现代码复用

  模板方法模式是一种实现代码复用的很好的手段。通过把子类的公共功能提炼和抽取，把公共部分放到模板中去实现。

缺点：

* 算法骨架不容易升级

  模板方法模式最基本的功能就是通过模板的制定，把算法骨架完全固定下来。事实上模板和子类是非常耦合的，如果要对模板中的算法骨架进行变更，可能就会要求所有相关的子类进行相应的变化。

#### 思考

模板方法的本质：固定算法骨架。

模板方法模式主要是通过制定模板，把算法步骤固定下来，至于谁来实现，模板可以自己提供实现，也可以由子类去实现，还可以通过回调机制让其他类来实现。

通过固定算法骨架来约束子类的行为，并在特定的扩展点来让子类进行功能扩展，从而让程序既有很好的复用性，又有较好的扩展性。

模板方法很好地体现了开闭原则和里氏替换原则。

### 策略模式 （ Strategy ）

#### 定义

定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

#### 认识

策略模式的功能是把具体的算法实现从具体的业务处理中独立出来，把它们实现成为单独的算法类，从而形成一系列的算法，并让这些算法可以相互替换。

策略模式的重心不是如何来实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。

策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正是因为这个平等性，才能实现算法之间可以相互替换。

所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。

策略算法是相同行为的不同实现。

运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。

#### 优缺点

优点：

* 定义一系列算法

  策略模式的功能就是定义一系列算法，实现让这些算法可以相互替换。

* 避免多重条件语句

  策略模式的一系列策略算法是平等的，是可以互换的，写在一起就是通过 if-else 结构来组织，如果此时具体的算法实现中又有条件语句，就构成了多重条件语句，使用策略模式能避免这样的多重条件语句。

* 更好的扩展性

  策略模式中扩展新的策略实现非常容易，只要增加新的策略实现类，然后在使用策略的地方使用这个新的策略实现就可以了。

缺点：

* 客户必须了解每种策略的不同

  让客户端来选择具体使用哪一个策略，就需要客户了解所有的策略，还要了解各种策略的功能和不同，这样才能做出正确的选择，这样也暴露了策略的具体实现。

* 增加了对象数目

  由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。

* 只适合扁平的算法结构

  策略模式的一系列算法地位是平等的，是可以相互替换的，事实上构成了一个扁平的算法结构，也就是在一个策略接口下，有多个平等的策略算法，就相当于兄弟算法。而且在运行时刻只有一个算法被使用，这就限制了算法使用的层级，使用的时候不能嵌套使用。

#### 思考

策略模式的本质：分离算法，选择实现。

因为分离并封装了算法，才能够很容易地修改和添加算法；也能很容易地动态切换使用不同的算法，也就是动态选择一个算法来实现需要的功能。

策略模式很好地体现了==开闭原则==。策略模式通过把一系列可变的算法进行封装，并定义出合理的使用结构，使得在系统出现新算法的时候，能很容易地把新的算法加入到已有的系统中，而已有的实现不需要做任何修改。

策略模式还很好地体现了==里氏替换原则==。策略模式是一个扁平结构，一系列的实现算法其实是兄弟关系，都是实现同一个接口或者继承的同一个父类。这样只要使用策略的客户保持面向抽象类型编程，就能够使用不同策略的具体实现对象来配置它，从而实现一系列算法可以相互替换。

### 状态模式 （ State ）

#### 定义

允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

#### 认识

所谓对象的状态，通常指的就是对象实例的属性的值；而行为指的就是对象的功能，再具体点说，行为大多可以对应到方法上。

状态模式的功能就是分离状态的行为，通过维护状态的变化，来调用不同状态对应的不同功能。

状态决定行为。

状态是运行期被改变的，因此行为也会在运行期根据状态的改变而改变，看起来，同一个对象，在不同的运行时刻，行为是不一样的，就像是类被修改了一样。

平等性和平行性：

* 平行性指的是各个状态的行为所处的层次是一样的，相互是独立的、没有关联的，是根据不同的状态来决定到底走平行线的哪一条。行为是不同的，当然对应的实现也是不同的，相互之间是不可替换的。
* 平等性强调的是可替换性，大家是同一行为的不同描述或实现，因此在同一个行为发生的时候，可以根据条件挑选任意一个实现来进行相应的处理。

#### 优缺点

优点：

* 简化应用逻辑控制

  使用单独的类来封装一个状态的处理。如果把一个大的程序控制分成很多小块，每块定义一个状态来代表，就可以把这些逻辑控制的代码分散到很多单独的状态类中去，这样就把着眼点从执行状态提高到整个对象的状态，使得代码结构化和意图更清晰，简化应用的逻辑控制。

* 更好地分离状态和行为

  通过设置所有状态类的公共接口，把状态和状态对应的行为分离开，把所有与一个特定状态相关的行为都放入一个对象中，使得应用程序在控制的时候，只需要关心状态的切换，而不用关心这个状态对应的真正处理。

* 更好的扩展性

  引入了状态处理的公共接口后，使得扩展新的状态变得非常容易，只需要新增加一个实现状态处理的公共接口的实现类，然后在进行状态维护的地方，设置状态变化到这个新的状态即可。

* 显式化进行状态转换

  状态模式为不同的状态引入独立的对象，使得状态的转换变得更加明确。而且状态对象可以保证上下文不会发生内部状态不一致的情况，因为上下文中只有一个变量来记录状态对象，只要为这一个变量赋值就可以了。

缺点：

* 一个状态对应一个状态处理类

  程序引入太多的状态类，程序变得杂乱

#### 思考

状态模式的本质：根据状态来分离和选择行为。

### 备忘录模式 （ Memento ）

#### 定义

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。

#### 认识

备忘录模式的功能，首先是在不破坏封装性的前提下，捕获一个对象的内部状态。

* 不破坏封装性

  对象不能暴露它不应该暴露的细节。

* 捕获对象的内部状态

  运行期间某个时刻对象的内部状态。

捕获这个内部状态，是为了在以后的某个时候，将该对象的状态恢复到备忘录所保存的状态，这才是备忘录真正的目的。

前面保存状态就是为了后面恢复，虽然不是一定要回复，但是目的是为了回复。

窄接口和宽接口：

* 窄接口

  管理者只能看到备忘录的窄接口，窄接口的实现中通常没有任何的方法，只是一个类型标识。窄接口使得管理者只能将备忘录传递给其他对象。

* 宽接口

  原发器能够看到一个宽接口，允许它访问所需要的所有数据，来返回到先前的状态。理想状况是：值允许生成备忘录的原发器来访问该备忘录的内部状态，通常实现成为原发器内的一个私有内部类。

#### 优缺点

优点：

* 更好的封装性

  通过使用备忘录对象，来封装原发器对象的内部状态，虽然这个对象是保存在原发器对象的外部，但是由于备忘录对象的窄接口并不提供任何方法，有效地保证了对原发器对象内部状态的封装，不把原发器对象的实现细节暴露给外部。

* 简化了原发器

  备忘录对象被保存到原发器对象之外，让客户来管理他们请求的状态，从而让原发器对象的到简化。

* 窄接口和宽接口

  通过引入窄接口和宽接口，使得不同的地方，对备忘录对象的访问是不一样的。窄接口保证了只有原发器才可以访问备忘录对象的状态。

缺点：

* 可能会导致高开销

  备忘录模式基本的功能，就是对备忘录对象的存储和恢复，它的基本实现方式就是缓存备忘录对象。这样一来，如果需要缓存的数据量很大，或者是特别频繁地创建备忘录对象，开销是很大的。

#### 思考

备忘录模式的本质：保存和恢复内部状态。

保存是手段，恢复才是目的。

备忘录模式备忘的就是原发器对象的内部状态，这些内部状态是不对外的，只有原发器对象才能够进行操作。

备忘录模式保存数据的目的就是为了在有需要的时候，恢复原发器对象的内部状态。所以恢复是备忘录模式的目的。

备忘录模式最主要的一个特点，就是封装状态的备忘录对象，不应该被除了原发器对象之外的对象访问。备忘录模式要解决的主要问题就是：在不破坏对象封装性的前提下，来保存和恢复对象的内部状态。

### 享元模式 （ Flyweight ）

#### 定义

运用共享技术有效地支持大量细粒度的对象。

#### 认识

* 变与不变

  享元模式设计的重点就在于分离变与不变。把一个对象的状态分成内部状态和外部状态，内部状态是不变的，外部状态是可变的。然后通过共享不变的部分，达到减少对象数量并节约内存的目的。

* 共享与不共享

  享元模式中，享元对象又有共享与不共享之分，这种情况通常出现在和组合模式合用的情况，通常共享的是叶子对象，一般不共享的部分是由共享部分组合而成的，由于所有细粒度的叶子对象都已经缓存了，缓存组合对象也就没有什么意义。

* 内部状态和外部状态

  享元模式的内部状态，通常指的是包含在享元对象内部的、对象本身的状态，是独立于使用享元的场景的信息，一般创建后就不再变化的状态，因此可以共享。

  外部状态指的是享元对象之外的状态，取决于使用享元的场景，会根据使用场景而变化，因此不可共享。如果享元对象需要这些外部状态的话，可以从外部传递到享元对象中，比如通过方法的参数来传递。

  享元模式真正缓存和共享的数据是享元的内部状态，而外部状态是不应该被缓存共享的。

  内部状态和外部状态是独立的，外部状态的变化不应该影响到内部状态。

#### 优缺点

优点：

* 减少对象数量，节省内存空间

  占用空间的大小等于每个对象实例占用的大小再乘以数量，对于享元对象来讲，基本是就只有一个实例，大大减少了享元对象的数量，并节省不少的内存空间。

缺点：

* 维护共享对象，需要额外开销

  在维护共享对象的时候，如果功能复杂，会有很多额外的开销，比如用一个线程来维护垃圾的回收。

#### 思考

享元模式的本质：分离与共享。

分离的是对象状态中变与不变的部分，共享的是对象中不变的部分。享元模式的关键之处就在于分离变与不变，把不变的部分作为享元对象的内部状态，而变化部分则作为外部状态，由外部来维护，这样享元对象就能够被共享，从而减少对象数量，并节省大量的内存空间。

### 解释器模式（ Interpreter ）

#### 定义

给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

#### 认识

解释器模式使用解释器对象来表示和处理相应的语法规则，一般一个解释器处理一条语法规则。理论上来说，只要能用解释器对象把符合语法的表达式表示出来，而且能够构成抽象的语法树，那都可以使用解释器模式来处理。

语法规则和解释器之间是有对应关系的，一般一个解释器处理一条语法规则，但是反过来并不成立。一条语法规则是可以有多种解释和处理的，也就是一条语法规则可以对应多个解释器对象。

#### 优缺点

优点：

* 易于实现语法

  在解释器模式中，一条语法规则用一个解释器对象来解释执行。对于解释器的实现来讲，功能久变得比较简单，只需要考虑这一条语法规则的实现就可以了。

* 易于扩展新的语法

  正是由于采用一个解释器对象负责一条语法规则的方式，使得扩展新的语法非常容易。扩展了新的语法，只需要创建相应的解释器对象，在创建抽象语法树的时候使用这个新的解释器对象就可以了。

缺点：

* 不适合复杂的语法

  如果语法特别复杂，构建解释器模式需要的抽象语法树的工作是非常艰巨的，再加上有可能会需要构建多个抽象语法树。所以解释器模式不太适合于复杂的语法。

#### 思考

解释器模式的本质：分离实现，解释执行。

解释器模式通过一个解释器对象处理一个语法规则的方式，把复杂的功能分离开；然后选择需要被执行的功能，并把这些功能组合成为需要被解释执行的抽象语法树；再按照抽象语法树来解释执行，实现相应的功能。

### 装饰模式（ Decorator ）

#### 定义

动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。

#### 认识

装饰模式能够动态地为对象添加功能，是从一个对象外部来给对象增加功能，相当于是改变了对象的外观。从外部使用系统的角度看，就不再是使用原始的那个对象了，而是使用被一系列的装饰器装饰过后的对象。

#### 优缺点

优点：

* 比继承更灵活

  继承是静态的，一旦继承，所有子类都有一样的功能。而装饰模式采用把功能分离到每个装饰器当中，然后通过对象组合的方式，在运行时动态地组合功能，每个被装饰的对象最终有哪些功能，是由运行期动态组合的功能来决定的。

* 更容易复用功能

  装饰模式把一系列复杂的功能分散到每个装饰器当中，一般一个装饰器只实现一个功能，使实现装饰器变得简单，更重要的是这样有利于装饰器功能的复用，可以给一个对象增加多个同样的装饰器，也可以把一个装饰器用来装饰不同的对象，从而实现复用装饰器的功能。

* 简化高层定义

  装饰模式可以通过组合装饰器的方式，为对象增添任意多的功能。因此在进行高层定义的时候，不用把所有的功能都定义出来，而是定义最基本的就可以了，可以在需要使用的时候，组合相应的装饰器来完成所需的功能。

缺点：

* 产生很多细粒度对象

  装饰模式是把一系列复杂的功能，分散到每个装饰器当中，一般一个装饰器只实现一个功能，这样会产生很多细粒度的对象，而且功能越复杂，需要的细粒度对象越多。

#### 思考

装饰模式的本质：动态组合。

动态是手段，组合才是目的。这里的组合有两个意思，一个是动态功能的组合，也就是动态进行装饰器的组合；另外一个是指对象组合，通过对象组合来实现为被装饰对象透明地增加功能。



### 职责链模式 （ Chain of Responsibility ）

#### 定义

使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连城一条链，并沿着这条链传递该请求，直到有一个对象处理该请求为止。

#### 认识

职责链模式主要用来处理“客户端发出一个请求，有多个对象都有机会来处理这一个请求，但是客户端不知道究竟谁会来处理他的请求”这样的情况。也就是需要让请求者和接受者解耦，这样就可以动态地切换和组合接受者了。

要注意，在标准的职责链模式中，只要有对象处理了请求，这个请求就到此为止，不再被传递和处理了。

如果要变形使用职责链，就可以让这个请求继续传递，每个职责对象对这个请求进行一定的功能处理，从而形成一个处理请求的职责链。

#### 优缺点

优点：

* 请求者和接收者松散耦合

  在职责链模式中，请求者并不知道接收者是谁，也不知道具体如何处理，请求者知识负责向职责链发出请求就可以了。而每个职责对象也不用管请求者或者是其他的职责对象，只负责处理自己的部分，其他的就交给其他的职责对象去处理。也就是说，请求者和接收者是完全解耦的。

* 动态组合职责

  职责链模式会把功能分散到单独的职责对象中，然后在使用的时候，可以动态组合职责形成职责链，从而可以灵活地给对象分配职责，也可以灵活地实现和改变对象的职责。

缺点：

* 产生很多细粒度对象

  职责链模式会把功能处理分散到单独的职责对象中，也就是每个职责对象只处理一个方面的功能，要把整个业务处理完，需要很多职责对象的组合，这样会产生大量的细粒度职责对象。

* 不一定能被处理

  职责链模式的每个职责对象只负责自己处理的那一部分，因此可能会出现某个请求，把整个链传递完了，都没有职责对象处理它。这就需要在使用职责链模式的时候，需要提供默认的处理，并且注意构建的链的有效性。

#### 思考

职责链模式的本质：分离职责，动态组合。

分离职责是前提，只有先把负责的功能分开，拆分成很多的步骤和小的功能处理，然后才能合理规划和定义职责类。可以有很多的职责类来负责处理某一个功能，让每个职责类负责处理功能的某一个方面，在运行期间进行动态组合，形成一个处理的链，把这个链运行完，功能也就处理完了。

动态组合才是职责链模式的精华所在，因为要实现请求对象和处理对象的解耦，请求对象不知道谁才是真正的处理对象，因此要动态地把可能的处理对象组合起来。由于组合记得方式是动态的，这就意味着可以很方便地把可能的处理对象组合起来。由于组合的方式是动态的，这就意味着可以很方便地修改和添加新的处理对象，从而让系统更加灵活和具有更好的扩展性。

这样做还会有一个潜在的优点，就是可以增强职责功能的复用性。如果职责功能是很多地方都可以使用的公共功能，那么它可以在多个职责链中复用。

### 桥接模式 （ Bridge ）

#### 定义

将抽象部分与它的实现部分分离，使它们都可以独立地变化。

#### 认识

所谓桥接，通俗点说就是在不同的东西之间搭一个桥，让它们能够连接起来，可以相互通讯和使用。桥接模式中是为被分离了的抽象部分和实现部分来搭桥。

桥接模式中的桥接是单向的，也就是只能是抽象部分的对象去使用具体实现部分的对象，而不能反过来，也就是个单向桥。

#### 优缺点

优点：

* 分离抽象和实现部分

  桥接模式分离了抽象部分和实现部分，从而极大地提高了系统的灵活性。让抽象部分和实现部分独立开来，分别定义接口，这有助于对系统进行分层，从而产生更好的结构化的系统。对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了。

* 更好的扩展性

  由于桥接模式把抽象部分和实现部分分离开了，而且分别定义接口，这就使得抽象部分和实现部分可以分别独立地扩展，而不会相互影响，从而大大地提高了系统的可扩展性。

* 可动态地切换实现

  由于桥接模式把抽象部分和实现部分分离开了，所以在实现桥接的时候，就可以实现动态的选择和使用具体的实现。也就是说一个实现不再是固定的绑定在一个抽象接口上了，可以实现运行期间动态地切换。

* 可减少子类的个数

  根据前面的描述，对于有两个变化纬度的情况，如果采用继承的实现方式，大约需要两个纬度上的可变好数量的乘积个子类；而采用桥接模式来实现，大约需要两个纬度上的可变化数量的和个子类。可以明显地减少子类的个数。

#### 思考

桥接模式的本质：分离抽象和实现。

桥接模式最重要的工作就是分离抽象部分和实现部分，这是解决问题的关键。只有把抽象部分和实现部分分离开了，才能够让它们独立地变化；只有抽象部分和实现部分可以独立地变化，系统才会有更好的可扩展性和可维护性。

桥接模式很好地实现了开闭原则。

桥接模式还很好地体现了：多用对象组合，少用对象继承。

### 访问者模式 （ Visitor ）

#### 定义

表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

#### 认识

访问者模式能给一系列对象透明地添加新功能，从而避免在维护期间对这一系列对象进行修改，而且还能变相实现服用访问者所具有的功能。

由于是针对一系列对象的操作，这也导致，如果只想给一系列对象中的部分对象添加功能，就会又些麻烦；而且要始终能保证把这一系列对象都调用到，不管是循环，还是递归，总之要让每个对象都要被访问到。

#### 优缺点

优点：

* 好的扩展性

  能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。

* 好的复用性

  可以通过访问者来定义整个对象结构通用的功能，从而提高复用程度。

* 分离无关行为

  可以通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。

缺点：

* 对象结构变化很困难

  不适用于对象结构中的类经常变化的情况，因为对象结构发生了改变，访问者的接口和访问者的实现都要发生相应的改变，代价太高。

* 破坏封装

  访问者模式通常需要对象结构开放内部数据给访问者和 ObjectStructure ，这就破坏了对象的封装性。

####思考

访问者模式的本质：预留通路，回调实现。

它的实现主要是通过预先定义好调用的通路，在被访问的对象上定义 accept 方法，在访问者的对象上定义 visit 方法；然后在调用真正发生的时候，通过两次分发技术，利用预先定义好的通路，回调到访问者具体的实现上。



## 常见的面向对象设计原则

### 单一职责原则 SRP （ Single Responsibility Principle ）

一个类应该仅有一个引起它变化的原因。

这里变化的原因就是所说的“职责”，如果一个类有多个引起它变化的原因，那么也就意味着这个类有多个职责，再进一步说，就是把多个职责耦合在一起了。

这会造成职责的相互影响，可能一个职责的变化，会影响到其他职责的实现，甚至引起其他职责随着变化，这种设计是很脆弱的。

###开放-关闭原则 OCP （ Open-Closed Principle ）

一个类应该对扩展开放，对修改关闭。一般也被称为开闭原则，开闭原则是设计中非常核心的一个原则。

开闭原则要求的是，类的行为是可以扩展的，而且是在不修改已有代码的情况下进行扩展，也不必改动已有的源代码活着二进制代码。

实现开闭原则的关键就在于合理地抽象、分离出变化与不变化的部分，为变化的部分预留下可扩展的方式，比如，钩子方法或是动态组合对象等。

### 里氏替换原则 LSP （ Lisk Substitution Principle ）

所谓里氏替换原则，指的是，子类型必须能够替换掉它们的父类型。这很明显是一种多态的使用情况，它可以避免在多态的应用中，出现某些隐蔽的错误。

事实上，当一个类继承了另外一个类，那么子类就拥有了父类中可以继承下来的属性和操作。理论上来说，此时使用子类型去替换掉父类型，应该不会引起原来使用父类型的程序出现错误。

但是，很不幸的是，在某些情况下是会出现问题的。比如，如果子类型覆盖了父类型的某些方法，或者是子类型修改了父类型的某些属性的值，那么远来使用父类型的程序就可能会出现错误，因为在运行期间，从表面上看，它调用的是父类型的方法，需要的是父类型方法实现的功能，但是实际运行调用的却是子类型覆盖实现的方法，而改方法和父类型的方法并不一样，于是导致错误的产生。

从另外一个角度来说，里氏替换原则是实现开闭的主要原则之一。开闭原则要求对扩展开放，扩展的一个实现手段就是使用继承；而里氏替换原则是保证子类型能够正确替换父类型，只有能正确替换，才能实现扩展，否则扩展了也会出现错误。

### 依赖倒置原则 DIP （ Dependence Inversion Principle ）

所谓依赖倒置原则，值得是，要依赖于抽象，不要依赖于具体类。要做到依赖倒置，典型的应该做到：

* 高层模块不应该依赖于底层模块，二者都应该依赖于抽象。
* 抽象不应该依赖于具体实现，具体实现应该依赖于抽象。

倒置接口所有权，这就是著名的 Hollywood （好莱坞）原则：不要找我们，我们会联系你。

### 接口隔离原则 ISP （ Interface Segregation Principle ）

所谓接口隔离原则，值得是，不应该强迫客户依赖于他们不用的方法。

这个原则用来处理那些比较“庞大”的接口，这种接口通常会有较多的操作声明，设计到很多的职责。客户在使用这样的接口的时候，通常会有很多他不需要的方法，这些方法对于客户来讲，就是一种接口污染，相当于强迫用户在一大堆“垃圾方法”中去寻找他需要的方法。

因此，这样的接口应该被分离，应该按照不同的客户需要来分离成为针对客户的接口。这样的接口中，只包含客户需要的操作声明，这样既方便了客户的使用，也可以避免因误用接口而导致的错误。

分离接口的方式，除了直接进行代码分离之外，还可以使用委托来分离接口，在能够支持多重继承的语言中，还可以采用多重继承的方式进行分离。

###最少知识原则 （ Least Knowledge Principle ）

最少知识原则，指的是，只和你的朋友谈话。

这个原则用来指导我们在设计系统的时候，应该尽量减少对象之间的交互，对象只和自己的朋友谈话，也就是只和自己的朋友交互，从而松散类之间的耦合。通过松散类之间的耦合来降低类之间的相互依赖，这样在修改系统的某一个部分的时候，就不会影响其他的部分，从而使得系统具有更好的可维护性。

哪些对象才能被当作朋友呢？

* 当前对象本身。
* 通过方法的参数传递进来的对象。
* 当前对象所创建的对象。
* 当前对象的实力变量所引用的对象。
* 方法内所创建或实例化的对象。

最少知识原则要求我们的方法调用必须保持在一定的界限范围之内，尽量减少对象的依赖关系。

### 其他原则

* 面向接口编程
* 优先使用组合，而非继承。
* 一个类需要的数据应该隐藏在类的内部。
* 类之间应该零耦合，或者只有传导耦合，换句话说，类之间要么没有关系，要么只使用另一个类的接口提供的操作。
* 在水平方向上尽可能统一地分布系统功能。



## 脚注

[^Target]: 适配器的接口方法
[^Adaptee]: 实现类，实现类也有自己的接口，而 target 接口中的方法并不完全等同于 Adaptee 的接口
[^延迟加载]: 一开始不要加载任何资源或者数据，一直等，等到马上就要使用这个资源或者数据了，躲不过去了才加载，所以也称 Lazy Load，经可能的节约资源。
[^缓存]: 当某些资源或者数据被频繁地使用，而这些资源或数据存储在系统外部，比如数据库、硬盘文件等，那么每次操作这些数据的时候都得从数据库或者硬盘上去获取，速度会很慢，造成性能问题。一个简单的解决方法就是：把这些数据缓存到内存里面，每次操作的时候，先到内存里面找，看有没有这些数据，如果有，就直接使用，如果没有就获取它，并设置到缓存中，下一次访问的时候就可以直接从内存中获取了，从而节省大量的时间。缓存是一种典型的空间换时间的方案。
[^依赖倒置原则]: 依赖抽象，不要依赖于具体类