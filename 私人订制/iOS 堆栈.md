### iOS 内存分区

---

![内存分区图](http://upload-images.jianshu.io/upload_images/1232160-0db68b7366e194e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 代码区

  存放函数的二进制代码

* 常量区

  存放常量，程序结束后由系统释放

* 全局区（全局静态区）

  存放全局变量，静态变量，程序结束后由系统释放

* 堆区

  heap ，由程序员分配和释放，不释放可能会引起内存泄漏

* 栈区

  stack 由编译器自动分配并释放，存放局部变量

### 堆栈的区别

* 堆

  iOS 操作系统中有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动将多余的部分重新放入空闲链表中。

  堆是向高地址扩展的数据结构，是不连续的内存区域。系统是用链表来管理堆区的内存地址的，链表的遍历方向是由低地址到高地址。堆的大小受限于计算机系统中有效的虚拟内存。堆的获取比较灵活，可获得内存也比较大。

  堆是由 alloc 分配的内存，速度慢，易产生内存碎片。

* 栈

  每一个函数在执行的时候都会向操作系统索要资源，栈区就是函数运行时的内存，栈区中的变量由编译器分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动释放。

  只要栈的内存空间大于所申请的空间，系统将为程序提供内存，否则会报内存溢出。

  栈是向低地址扩展的数据结构，是一块儿连续的内存区域。栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是 2M（也有的说 1M ，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示 overflow ，从栈获取的内存空间都会比较小。

  由系统自动分配，速度快，不会产生内存碎片。

### 参考链接

[iOS程序中的内存分配 栈区堆区全局区](http://www.jianshu.com/p/f3c1b920e8eb)

[iOS 堆和栈的区别？](http://www.jianshu.com/p/c8e1d91dda99)

[iOS 堆和栈 的理解](http://www.cnblogs.com/qiyer/p/5637773.html)

[ios中对堆栈的理解及两者件的区别](http://m.blog.csdn.net/article/details?id=49204779)